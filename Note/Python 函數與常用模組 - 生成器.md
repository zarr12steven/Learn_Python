### 生成器

**什麼是列表生成式？**

這個是基本的列表

```
>>> a = [1, 2, 3]
>>> a
[1, 2, 3]
```

也可以用另一種方式來表示

```
>>> [ i*2 for i in range(10)]
[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
```

但這二個列表有什麼差別嗎？

第一種列表數據已經是寫死了，不能改變，第二種列表在產生的時候，是動態去產生的，而第二種寫法，也可以用下面代碼來實現。

```
>>> a = []
>>> for i in range(10):
...     a.append(i*2)
...
>>> a
[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
```

嗯！效果跟第二種寫法的結果是一樣的，所以第二種寫法，其實就是 `列表生成式`，主要的目的就是把代碼變的更簡潔一點。

通過列表生成式，我們可以直接創建一個列表，但是受到記憶體的限制，列表的容量是有限，假設創建一個100萬個元素的列表，不僅占用很大的存儲空間，實際上我們卻只會存取這個列表的前面幾個元素，那後面絕大多數的元素占用的空間，不就白白浪費了？！

所以，如果列表元素可以按照某種算法推算出來的，那我們是不是可以在循環的過程中，不斷地推算出後面的元素呢？！這樣就不用建立完整的列表了，進而省下大量的存儲空間，在Python中，這樣一邊循環一邊計算的機制，就稱為 `生成器(generator)`

在Python2.x版中， `range(10)` 是已經把所有元素都準備好，放在記憶體裡了，而在Python3是還沒準備好，所以就可以節省一些記憶體的空間，至於為什麼呢？！細節不在此說明 只需要先知道就好了。

```
# Python2.x

>>> range(10)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

```
# Python3 

>>> range(10)
range(0, 10)
```

能不能在調用到所需要的元素後，才生成相對應的元素？！實際上是可以的，我們接下來就以『有規律』的來做一個簡單的生成器

```
>>> ( i*2 for i in range(10) )
<generator object <genexpr> at 0x103cd8910>
```

上面這個代碼就是一個 `生成器`，每循環一次就乘上2

接下來我們來驗証一下，為什麼 `生成器` 會比 `列表生成式` 還要省空間

首先我們先來觀察，使用 `列表生成式` 來觀察列表生成的結果，把下面的代碼，逐一貼在Python3解釋器中觀察。

* `[ i*2 for i in range(100) ]`
* `[ i*2 for i in range(1000) ]`
* `[ i*2 for i in range(10000) ]`
* `[ i*2 for i in range(100000) ]`
* `[ i*2 for i in range(1000000) ]`
* `[ i*2 for i in range(10000000) ]`  =>  我的筆電執行到這就變慢了
* `[ i*2 for i in range(100000000) ]`

有發現執行到 `range(10000000)` 時，就變慢了，這是因為列表生成時，會一次直接打印所有列表中的元素，而當你的機器的記憶體空間不夠時，就會發生這樣子的問題

再來觀察把 `列表生成式` 賦值給 `a`

```
>>> a = [ i*2 for i in range(10000000) ]
>>> a
...(略), 153018, 153020, 153022, 153024, 153026, 153028, 153030, 153032, 153034, 153036, 153038, 153040, 153042, 153044, 153046, 153048, 153050, 153052, 153054, 153056, 153058, 153060, 153062, 153064, 153066, 153068, 153070, 153072, 153074, 153076, 153078, 153080, 153082, 153084, 153086, 153088, 153090, 153092, 153094, 153096, 153098, 153100, 153102, 153104, 153106, 153108, 153110, 153112, 153114, 153116, 153118, 153120, 153122, 153124, 153126, 153128, 153130, 153132, 153134, 153136, 153138, 153140, 153142, 153144, 153146, 153148, 153150, 15^CTraceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyboardInterrupt
>>> 
>>> # 實際去訪問a列表中的第10000個元素
>>> a[10000]
20000
>>>
```


再來觀察 `生成器` 賦值給 `b`

```
>>> b = ( i*2 for i in range(10000000) )
>>> b
<generator object <genexpr> at 0x1042c80a0>
>>>  #↑實際上會發現根本沒有生成任何元素，只是返回了一個記憶體位址而已 
>>>
>>>
>>> #↓直接去循環這個生成式，這樣才會去調用它，才會生成對應的元素
>>> for i in b:
...     print(i)
...(略)
99240
99242
99244
99246
99248
^C99260
Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
KeyboardInterrupt
>>>
>>> #↓同樣去用列表的方式去訪問它
>>> c[10000]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'generator' object is not subscriptable
>>>
```

由上面實驗觀察可以得知，`生成器` 是要調用時，才會產生相應的數據，所以不支援列表的切片的形式取得。

那除了for循環可以取得數據外，那還有其他方式嗎？！目前只有一個方法叫 `next`

* Python2.x 的用法： `next()`
* Python3的用法： `__next__()`

那如果要個別訪問時，那要怎麼訪問呢？

```
>>> # 請看上面最後停止的數字是 99260
>>> b.__next__()
99262
>>> b.__next__()
99264
>>> b.__next__()
99266
```

`生成器是不能往前調用的`，那…生成器是怎麼省記憶體呢！？ 生成器 `只記得當前的位置`，
所以我們創建了一個generator後，基本上不會調用 `__next__()`，而是透過for循環來調用它，並且不需要關心StopIteration的錯誤。


如果推算的算法比較複雜，用類似列表生成式的for循環無d法實現的時候，還可以用函數來實現，例如，著名的斐波拉契數列(Fibonacci)，除了第一個和第二個數之外，任意一個數都可以由前面二個數相加得到：

```
1, 1, 2, 3, 5, 8, 13, 21, 34, ....
```

斐波拉契數列(Fibonacci)用列表生成式寫不出來，但是用函數把它打印出來卻很容易

```
#!/usr/bin/env python3
# -*- coding:utf-8 -*-

def fib(max):
    n, a, b = 0, 0, 1
    while n < max:
        print(b)
        a, b = b, a + b
        # a = b     => a = 1, b = 2 ; a = b,  a = 2
        # b = a + b => b = 2 + 2 = 4
        n = n + 1
    return 'done'

print(fib(10))


```
